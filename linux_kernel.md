# Linux Kernel Development

> “对内核各个核心子系统有个整体把握，包括它们提供什么样的服务，为什么要提供这样的服务，又是怎样实现的”

## 一、Linux 内核简介

**Linux 是类 Unix 系统，但它不是 Unix。**Linux 借鉴了 Unix 的许多设计并且实现了 Unix 的 API，但 Linux 没有像其他 Unix 变种那样直接使用 Unix 的源代码。必要的时候，Linux 的实现可能和其他各种 Unix 的实现大相径庭，**但它没有抛弃 Unix 的设计目标并且保证了应用程序编程接口的一致。**

Linux 系统的基础是内核、C 库、工具集和系统的基本工具，**通常一个内核由负责响应中断的中断服务程序，负责管理多个进程从而分享处理器时间的调度程序，负责管理进程地址空间的内存管理程序和网络、进程间通信等系统服务程序共同组成。**

## 二、从内核出发

<div style="text-align:center;"><b>内核源码树的根目录描述-Linux 2.6</b></div>

| 目录          | 描述                                 |
| ------------- | ------------------------------------ |
| arch          | 特定体系结构的源码                   |
| block         | 块设备 I/O 层                        |
| crypto        | 加密 API                             |
| Documentation | 内核源码文档                         |
| drivers       | 设备驱动程序                         |
| fireware      | 使用某些驱动程序而需要的设备固件     |
| fs            | VFS 和各种文件系统                   |
| include       | 内核头文件                           |
| init          | 内核引导和初始化                     |
| ipc           | 进程间通信代码                       |
| kernel        | 像调度程序这样的核心子系统           |
| lib           | 通用内核函数                         |
| mm            | 内存管理子系统和 VM                  |
| net           | 网络子系统                           |
| samples       | 示例，示范代码                       |
| scripts       | 编译内核所用的脚本                   |
| security      | Linux 安全模块                       |
| sound         | 语音子系统                           |
| usr           | 早期用户空间代码（所谓的 initramfs） |
| tools         | 在 Linux 开发中有用的工具            |
| virt          | 虚拟化基础结构                       |

内核开发不同于用户空间内应用程序开发的点：

+ 编程时不能访问 C 库，也不能访问标准的 C 头文件
+ 编程时必须使用 GNU C
+ 编程时缺乏像用户空间那样的内存保护机制
+ 编程时难以执行浮点运算
+ 内核给每个进程只有一个很小的定长堆栈
+ 内核支持异步中断、抢占和 SMP，因此必须时刻注意同步和并发
+ 要考虑可移植性的重要性

## 三、进程管理

> 进程是处于执行期的程序以及相关资源的总称

### 1. 进程描述符

内核通过**双向循环链表**来存储进程描述符，进程描述符**完整**的描述了一个正在执行的程序：它打开的文件、挂起的信号、进程的地址空间、进程状态等。

内核会为每个进程分配一个内核栈，当进程陷入内核时，系统调用函数使用的是内核栈。

![thread kernel stack](https://raw.githubusercontent.com/chi199702/notes/main/image/thread_kernel_stack.png)

```c
union thread_union {
    struct thread_info thread_info;
    unsigned long stack[THREAD_SIZE / sizeof(long)];
}
```

`struct thread_info`位于栈底，和内核栈**共享同一片空间**(可能是为了节省空间)。

`struct thread_info`有指向进程描述符的`struct task_struct*`，后者有指向内核栈底的`void* stack`

### 2. 进程状态

+ TASK_RUNNING，进程正在运行或在可执行队列中等待被调度
+ TASK_INTERRUPTIBLE，进程被阻塞，等待某些条件达成后被唤醒，**也可被信号提前唤醒**，唤醒后进入 TASK_RUNNING 状态
+ TASK_UNINTERRUPTIBLE，和 TASK_INTERRUPTIBLE 的区别在于**不可被信号提前唤醒**，使用得较少
+ _TASK_TRACED，被其他进程跟踪的进程，例如通过 ptrace 对调试程序进行跟踪
+ _TASK_STOPPED，进程停止运行，通过发生在(调试时)接收到 SIGSTOP/SIGTSTP/SIGTTIN/SIGTTOU 等信号时

![thread_status](https://raw.githubusercontent.com/chi199702/notes/main/image/thread_status.png)

### 3. 进程创建

Unix 中创建子进程首先通过`fork`拷贝父进程，子进程再通过`exec`函数族来执行程序。

`fork`采取写时拷贝机制，只有当子进程(或父进程?)**写入**时才拷贝父进程的地址空间，否则与父进程共享之。

内核为了避免写时拷贝，`fork`后有意让子进程先运行。

### 4. 线程创建

Linux 只是将线程看成一个与其他进程共享某些资源的**进程**。

> 场景：在一个进程中创建 4 个线程，在专门提供了支持线程机制的操作系统中，该进程的描述符会包含 4 个指向不同线程的指针；而对于 Linux 系统来说，其仅仅创建 4 个进程并指定它们共享某些资源。

内核线程只在内核空间运行，和普通线程一样，可以被调度，也可以被抢占。

### 5. 进程终结

进程终结时所需的清理工作和进程描述符的删除被分开执行。在父进程获得已终结的子进程的信息后，或者通知内核它并不关注那些信息后，子进程的`task_struct`才被释放。

对于僵尸进程，内核会试图在进程组中找到其他进程作为僵尸进程的父进程，如果找不到则返回`init`进程，并为该僵尸进程的兄弟进程设置新的父进程。

## 四、进程调度

> 和其他操作系统类似，Linux也支持两种进程：普通进程和实时进程。实时进程具有一定程度上的紧迫性，要求对外部事件做出非常快的响应；而普通进程则没有这种限制。所以，调度程序要区分对待这两种进程，通常，实时进程要比普通进程优先运行。这两种进程的区分也反映在`task_struct`数据结构中了。

### 1. 相关概念

1. 进程可简单的分为**I/O 消耗型**和**处理器消耗型**，I/O 消耗型相比于处理器消耗型需要更频繁的被调度。

2. Linux 是抢占式操作系统，其采用了**完全公平调度算法(CFS)**来调度<u>普通</u>进程，进程的优先级被 nice 值（针对普通进程）和实时优先级（针对实时进程）所影响：

   + nice 值：代表进程获取时间片的**比例**，范围是 [-20, 19]，默认值为 0，**越大的 nice 值优先级越低**

   + 实时优先级：范围是 [0, 99]，越高的实时优先级数值意味着进程优先级越高，**任何实时进程的优先级都高于普通的进程，也就是说实时优先级和 nice 优先级处于互不相交的两个范畴。**

3. 针对于时间片的分配，Linux 并没有像 Unix 那样分配固定的时间片给进程，而是将**处理器的使用比**划分给进程，在这个比例的基础上还会受到 nice 值的影响，最终给每个进程生成一个处理器比例，**确保了每个进程公平获得了处理器使用比**。

4. Linux 的 CFS 调度器，其抢占时机取决于新的可运行程序消耗了多少处理器使用比，如果消耗的使用比比当前进程小，则新进程立刻投入运行，否则，推迟其运行。

> 总结一下，任何进程获得的处理器时间是由它自己和其他所有可运行进程 nice 值的相对差值决定的。nice 值对时间片的作用不再是算数加权，而是几何加权。任何 nice 值对应的绝对时间不再是一个绝对值，而是处理器的使用比。CFS 称为公平调度器是因为它确保给每个进程公平的处理器使用比。正如我们知道的，CFS 不是完美的公平，它只是近乎完美的多任务。但是它确实在多进程环境下，降低了调度延迟带来的不公平性。

### 2. 算法实现

Linux 调度器是以模块化方式提供的，它允许多种不同的**可动态添加**的调度算法<u>并存</u>，对不同类型的进程可针对性的选择不同的调度算法。

1. 时间记账

   进程描述符中拥有`struct sched_entity`结构体，该结构体的成员变量`vruntime`记录了进程的虚拟运行时间。

2. 进程选择

   + CFS 使用**红黑树**来组织可运行进程队列，树中最左侧的叶子节点就是`vruntime`最小的进程，该进程会被调度运行
   + 当进程变为可运行状态（被唤醒）或者通过`fork`调用第一次创建进程时，其会被加入到红黑树中
   + 当进程堵塞（变为不可运行状态）或者终止时（结束运行），其从红黑树中被移除

3. 调度器入口

   进程调度的主要入口函数是`schedule()`，它是内核其他部分用于调用进程调度器的入口：选择哪个进程运行，何时将其投入运行。`schedule`通常都需要和一个具体的调度类相关联，也就是说，它会找到一个最高优先级的调度类——后者需要有自己的可运行队列，然后问后者谁才是下一个该运行的进程。该函数中唯一重要的它会**以优先级为序，从高到低，依次检查每一个调度类，并且从最高优先级的调度类中，选择最高优先级的进程。**

4. 睡眠和唤醒

   休眠的一个常见原因就是文件 I/O。无论哪种情况，内核的操作都相同：进程把自己标记成休眠状态，从可执行红黑树中移出，放入等待队列，然后调用`schedule()`选择和执行一个其他进程。唤醒的过程刚好相反：进程被设置为可执行状态，然后再从等待队列中移到可执行红黑树中。

### 3. 抢占和上下文切换

1. 上下文切换

   上下文切换，也就是从一个可执行进程切换到另一个可执行进程。由函数`context_switch()`函数负责处理，进行切换时，主要完成以下两项基本的工作：

   + 把虚拟内存从上一个进程映射切换到新进程中（个人理解是让内核知道当前新进程的虚拟内存范围）
   + 从上一个进程的处理器状态切换到新进程的处理器状态。这包括保存、恢复栈信息和寄存器信息，还有其他任何与体系结构相关的状态信息，都必须以每个进程为对象进行管理和保存

2. 用户抢占

   内核提供了一个`need_resched`标志来表明**是否需要重新执行一个调度。**内核检查该标志，若其被设置，调用`schedule()`来切换到一个新的进程。

   用户抢占在以下情况发生时都会检查`need_resched`，其被设置就会导致`schedule()`被调用从而发生用户抢占

   + 从系统调用返回用户空间时
   + 从中断处理程序返回用户空间时

3. 内核抢占

   在不支持内核抢占的内核中，内核代码可以一直执行，到它完成为止。Linux 在 2.6 后支持内核抢占，只要当前内核任务没有持有锁，内核就可以进行抢占。在每个进程的`thread_info`都有`preempt_count`计数器，每当使用锁的时候数值 +1，释放锁的时候数值 -1，当数值为 0 时说明没持有锁即可以被抢占。所以在内核中发生抢占除了检查`need_resched`外还要检查`preempt_count`。

   内核抢占在以下情况发生：

   + 中断处理程序正在执行，且返回内核空间之前
   + 内核代码再一次具有可抢占性的时候
   + 如果内核中的任务显式地调用`schedule()`
   + 如果内核中的任务阻塞（这同样也会导致调用`schedule()`）

### 4. 实时调度策略

Linux 提供了两种实时调度策略：SCHED_FIFO 和 SCHED_RR，而普通的、非实时的调度策略是 SCHED_NORMAL 即 CFS。

+ SCHED_FIFO 级的进程会比任何 SCHED_NORMAL 级的进程都先得到调度，并且它不基于时间片运行，一旦其在运行，就会一直执行，知道它自己受阻或显式地释放处理器为止；只有更高优先级的 SCHED_FIFO 或者 SCHED_RR 任务才能抢占 SCHED_FIFO 进程。如果有两个或者更多的同优先级的 SCHED_FIFO 级进程，它们会轮流执行，但是依然只有在它们愿意让出处理器时才会退出。
+ SCHED_RR 和 SCHED_FIFO 的不同在于 SCHED_RR 进程拥有时间片，其不能一直执行下去。

### 5. 与调度相关的系统调用

Linux 内核提供了设置和获取进程的 nice 值、调度策略、实时优先级、处理器的亲和力（设置进程只在 1 个处理器或一些处理器上运行）等系统调用。

## 五、系统调用

> 系统调用是用户空间的程序访问内核的唯一手段。

1. 系统调用会通过返回一个`long`类型的返回值来表示成功或者失败。通常但不绝对，负数表示错误，0 表示成功，出现错误的时候 C 库会把错误码写入`error`全局变量，通过调用`perror()`库函数可把错误码翻译成用户可理解的错误字符串。

2. 每个系统调用都有一个<u>系统调用号</u>，其和传递给系统调用的<u>参数</u>一样被存放在寄存器中供内核访问。

3. 当执行系统调用时，通知内核的机制是靠<u>软中断</u>实现的：通过引发一个异常来促使系统切换到内核态去执行**异常处理程度**，此时的异常处理程序实际上就是系统调用处理程序。

4. 在用户空间的应用程序使用了 C 库中包含了<u>系统调用</u>的库函数后，相当于把所使用的系统调用的**系统调用号、参数**、传递给了系统调用处理程序`system_call()`，再由`system_call()`选择对用的系统调用函数来运行。

   ![](https://raw.githubusercontent.com/chi199702/notes/main/image/system_invoke_application.png)

5. 当内核执行系统调用的时候<u>进程上下文</u>，此时的`current`指针指向引发系统调用的进程。值得注意的是，程序不管在用户空间还是内核空间运行，进程上下文都是共享的。

## 六、内核数据结构

内核中主要使用到的数据结构有 4 种：链表、队列、映射、二叉树

+ 链表：内核中的链表与众不同，使用方式是在我们的结构体当中嵌入内核提供的链表结构`list_head`，由于这样做导致只能得到自定义结构体中的`list`成员，所以内核提供了宏`container_of()`来获取自定义结构体中的任何变量，此外内核基于`container_of()`提供了`list_entry()`宏来获取一个指向自定义结构体的指针

  ```c
  struct list_head {
      struct list_head* prev;
      struct list_head* next;
  };
  
  struct fox {
      int a;
      int b;
      struct list_head list;	// list_head 是内核提供的结构体
  };
  ```

+ 链表、队列、映射、二叉树等都提供了许多能满足日常需求的 API

> 对于每种数据结构，内核都提供了许多对应的 API 来完成常见的需求，所以我们不应该重写内核中已提供的数据结构，而应该**重用**它们。

## 七、中断和中断处理
