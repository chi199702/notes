# 操作系统真象还原

## 第 0 章 一些你可能正感到迷惑的问题

### 0.1 操作系统是什么

操作系统和用户进程的关系就像是社会组织和人们之间的关系，人们得通过社会管理机构来申请社会资源，不能自由创造资源（比如造武器、烟）。

### 0.2 你想研究到什么程度

学习操作系统不必纠结于硬件内部是如何工作的，只需要认为给硬件一个输入，硬件会根据其功能给予一个输出即可，即学习操作系统需要基于一些公设，不能把知识点越展越开一直递归下去。

### 0.3 写操作系统，哪些需要我来做

操作系统能做什么，取决于主机上硬件的功能，所以写操作系统需要了解硬件，这些硬件提供了软件方面的接口，这样我们的操作系统通过软件（计算指令）就能够控制硬件（比如将硬件端口相应的置位）。所以需要做的就是知道如何通过计算机指令来控制硬件，参考<u>硬件手册</u>就是必须的了。

### 0.4 软件是如何访问硬件的

OS 开发者不可能为每款硬件都编写对应的驱动程序，通过**硬件适配器**即 IO 接口，接口就是标准，大家生产出来的硬件都遵循这种标准的话就实现通用了。

硬件在输入输出上大体分为串行接口和并行接口。

CPU 访问外部硬件有两个方式：

+ 将某个外设内存映射到一定范围的地址空间中，CPU 通过地址总线访问该内存区域时就像访问主板上的物理内存一样，在该映射内存写数据会落到外设的内存中，比如显卡中的显存。
+ 外设通过 IO 接口与 CPU 通信，CPU 通过访问 IO 接口来间接访问外设，IO 接口上存在一些寄存器即**端口**，给端口置位就会驱使硬件工作。

### 0.5 应用程序是什么，和操作系统是如何配合到一起的

编译器提供了一套库函数，库函数封装了<u>系统调用</u>，这样的代码成为运行库，C 语言的运行库称为**C运行库（C Runtime Library）。**

### 0.6 为什么称为“陷入”内核

如果把软件分层的话，最外层是应用程序，里面是操作系统。

### 0.7 内存访问为什么要分段

分段是从 CPU 8086 开始的，以前编程都直接使用<u>物理地址</u>，所以两个程序可能使用到相同的物理内存空间，采用分段的方式首先可以**重定位**，解决了不同程序使用相同物理内存导致冲突的问题。

其次是由于当时寄存器只有 16 位，可寻址范围不能涵盖整块内存，所以采用“段基址+段内偏移量”的方式可以将大内存分成可以访问的小段，这样就能够访问到所有内存了。

16 位的寄存器如何使用 20 位的地址总线呢？地址处理单元将**段基址 * 16 + 段内偏移量**即可得到 20 位的地址。

### 0.8 代码中为什么分为代码段、数据段？这和内存访问机制中的段是一回事吗

可以理解位就是一回事，内存分段指的是处理器为访问内存而采用的机制，程序分段是软件中人为逻辑划分的内存区域，其本身也是内存区域，所以处理器在访问该区域时，也会采用内存分段机制，用段寄存器指向该区域的起始地址。

### 0.9 物理地址、逻辑地址、有效地址、线性地址、虚拟地址的区别

+ 物理地址就是物理内存真实的地址
+ 线性地址是在“保护模式”下的”段基址+段内偏移量“
+ 虚拟地址，在“保护模式”下，段基址是 GDT 的索引，其索引到 GDT 中的段描述符，段描述符中记录了段的地址、大小等信息，这样就得到了段基址，若没有开启分页功能，线性地址就是物理地址，否则，线性地址就是虚拟地址，虚拟地址要经过 CPU 页部件转换成具体的物理地址。
+ 有效地址和逻辑地址就是段内偏移地址

![image-20230722111441458](https://raw.githubusercontent.com/chi199702/notes/main/image/image-20230722111441458.png)

### 0.10 什么是段重叠

不同的“段基址+段内偏移量”可能会定位到一个相同的物理地址。

### 0.11 什么是平坦模式

实模式下，访问超过 64 KB 的内存需要迂回变通的指定不同的段基址。

保护模式下，由于其是 32 位的（没搞懂），访存范围达到 4GB（可是现在都有 16GB 内存了），所以用一个段就能够访问到硬件所支持的所有内存，感觉很”平坦“。

### 0.12 cs、ds 这类 sreg 段寄存器，位宽是多少

32 位 CPU 有两种不同的工作模式：实模式和保护模式。实模式下，CS、DS、ES、SS 中的值为段基址，是具体的物理地址，在保护模式下，上述寄存器中的是“段选择子”，但是其宽度仍然为 16 位宽度。

在 32 位 CPU 中，sreg 无论是工作在 16 位的实模式还是 32 位的保护模式，用的段寄存器都是同一组，并且都是 16 位宽。

### 0.13 什么是工程，什么是协议

工程就是项目，协议就是大家约定俗成的规定

### 0.14 为什么 Linux 系统下的应用程序不能在 Windows 系统下运行

+ 格式不同，Linux 系统下的可执行程序格式是 elf（Executable and Linking Format），Windows 下可执行程序是 PE（portable executable）
+ 系统 API 不同

### 0.15 局部变量和函数参数为什么要放在栈中

堆就是堆，堆栈就是栈。

### 0.16 为什么说汇编语言比 C 语言快

谬论。只是 C 语言被编译成汇编语言后的代码量更大，这是为了方便程序员编程而必然带来的后果。

### 0.17 先有的语言，还是先有的编译器，第 1 个编译器是怎么产生的

先有编程语言，接着依据如何解析编程语言来设计了编译器。

Python 解析器是用 C 语言编写的，GCC 也是用 C 语言编写的，程序代码是纯文本，编译器只是依靠逐个字符来解析代码来生成能在平台 CPU 上执行的机器码。

新版本的编译器只能是用老版本的编译器来编译。

### 0.18 编译型程序与解释型程序的区别

脚本中的代码从来没有真正在 CPU 上去执行，脚本解析器只是逐个字符去解析脚本代码，将脚本代码转换成对应的 C 代码来让 CPU 执行，整个过程只有脚本解析器这一个进程。

而编译型程序是真正运行在 CPU 上的，其本身会启动一个进程来运行。

### 0.19 什么是大端字节序、小端字节序

+ 小端字节序：低字节放到低地址处，高字节放在高地址处
+ 大端字节序：低字节放到高地址处，高字节放在低地址处

### 0.20 BIOS 中断、DOS 中断、Linux 中断的区别

异常：CPU 内部产生的事件，比如分母是 0。

中断：外部设备产生的事件

中断向量表 IVT 是由 BIOS 和 DOS 建立的，BIOS 在内存地址 0x0000 处初始化并在中断向量表中添加各种中断处理程序，IVT 的长度是 1024 个字节，每个中断处理程序占 4 个字节，所以系统最多拥有 256 个中断处理程序。中断处理程序提供了访问硬件的方式，无非就是通过 in/out 指令来读写外设的端口。

每个外设在出厂时都会在其内存中给出 BIOS 和功能调用程序、初始化代码，那么 CPU 如何访问到外设的内存呢？见**0.4 软件是如何访问硬件的**。

DOS 中断感觉不重要，Linux 内核进入保护模式后 IVT 已经不存在了，取而代之的是**中断描述符表**。

### 0.21 Section 和 Segment 的区别

section 称为节，是指在汇编源码中经由关键字 section 或 segment 修饰、逻辑划分的指令或数据区域，汇编器会将这两个关键字修饰的区域在目标文件中编译成节，也就是所“节”最初诞生于目标文件中。

segment 称为段，是链接器根据目标文件中属性相同的多个 section 合并后的 section 集合，这个集合成为 segment，链接器把目标文件链接成可执行文件，因此段最终产生于可执行文件中。我们平时所说的可执行程序中的代码段/数据段等指的就是 segment。

### 0.22 什么是魔数

对魔数的简单的阐述就是：不明就理地出现一个数字，不知道其是什么意思，感觉看不透，猜不出，就是魔法一样很神秘。了解一定上下文的人肯定知道是什么意思，但是尽量少用魔数，其实就是建议少用硬编码多用**宏**来代替**常量**。

### 0.23 操作系统是如何识别文件系统的

通过使用约定俗成的“魔数”来识别文件系统

### 0.24 如何控制 CPU 的下一条指令

通过改变 CPU 中指令寄存器的值，比如 x86 体系结构的 CPU 可以改变 CS:IP 的值，而 ARM 体系结构的 CPU 可以改变寄存器 PC 的值

### 0.25 指令集、体系结构、微架构、编程语言

CPU 可以识别的指令的集合就是指令集。目前指令集有复杂指令集 CISC 和精简指令集 RISC。Intel 和 AMD 的产品用的都是 CISC，AMD 的 x86 指令集是 Inter 授权给他们的，也就是说虽然 AMD 和 Intel 的 CPU 的内部构造虽然不同，但是它们 CPU 的指令集都是一样的，所以在 Intel 上可运行的应用也可运行在 AMD 上。对于 AMD 以何种硬件实现方式来使用 Intel 授权给他们的指令集不得而知，CPU 的这种实现方式就叫**微架构**。**指令集是具体的一套指令编码，微架构就是指令集的物理实现方式**。

### 0.26 库函数是用户进程与内核的桥梁

库函数中包含着系统调用，系统调用可以控制硬件，所以用户代码通过使用库函数可以和内核进行打交道并控制硬件。

### 0.27 转义字符与 ASCII 码

这个没什么好说的

### 0.28 MBR、EBR、DBR 和 OBR 各是什么

计算机通电后首先是 BIOS 得到控制权，BIOS 找到主引导程序 MBR（Main Boot Record）并把其加载到物理地址 0x7c00 来把控制权交给它，它按照规定处于磁盘上 0 盘 0 道 1 扇区的位置，MBR 引导扇区中的内存是（一共 512 字节）：

+ 446 字节的引导程序及参数
+ 64 字节的分区表
+ 2 字节结束标记 0x55 和 0xaa

MBR 在其 64 字节的分区表中寻找”次引导程序“来接力控制权，分区表中每个分区项占用 16 个字节，所以一共只能存在 4 个分区，在有操作系统的分区上，其对应的分区表项的第一个字节是 0x80，否则就是 0。对于存在操作系统的分区，其中含有操作系统加载器，MBR 将加载器代码加载到内存中进行执行来把控制权交接给次引导程序。

次引导程序即操作系统加载器规定存放在分区中的第 1 个扇区，这个扇区中的次引导程序也成为操作系统引导记录 OBR（OS Boot Record），此扇区也称为 OBR 引导扇区，OBR 扇区的前 3 个字节存放了跳转指令，该跳转指令可以将处理器带入操作系统引导程序，进入内核。

DBR（DOS Boot Record） 是 OBR 的前身，是 DOS 操作系统时期的概念。

EBR（Extend Boot Record）是扩展分区，位于各子扩展分区中最开始的扇区，其中也包含同 MBR 中一样的分区表，扩展分区是为了解决分区数量限制问题而提出来的，扩展分区里可以划分 1 个逻辑分区。

![image-20230723121609932](https://raw.githubusercontent.com/chi199702/notes/main/image/image-20230723121609932.png)

MBR 和 EBR 是由分区管理工具创建维护的，不属于操作系统的管理范畴，OBR 是各分区（主分区或逻辑分区）最开始的扇区，属于操作系统管理。

MBR、EBR、DBR、OBR 都包含引导程序，因此它们都称为引导扇区，只要该扇区中存在可执行程序，该扇区就是可引导扇区。

**如果某个扇区位于整个硬盘的最开始处，并且是以 0x55 和 0xaa 结束的，该扇区就被认定为 MBR 扇区，如果某个扇区位于各分区最开始的位置，并且以 0x55 和 0xaa 结束的，该扇区就被认为是 OBR 扇区。**

**分区表只存在于 MBR 和 EBR 中。**

MBR 位于整块硬盘最开始的块，EBR 位于每个子扩展分区，各子扩展分区中只有一个逻辑分区，MBR 和 EBR 位于**分区之外**的扇区（OBR 在分区之内的扇区），而 OBR 位于主分区或逻辑分区最开始的扇区。

## 第 1 章 部署工作环境

