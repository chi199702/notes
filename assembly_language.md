# 汇编语言

## 第 1 章 基础知识

1. 汇编语言的组成：
   + 汇编指令：机器码的助记符，有对应的机器码，**汇编指令是汇编语言的核心，它决定了汇编语言的特性**
   + 伪指令：没有对应的机器码，由(汇编)编译器执行，计算机并不执行
   + 其他符号：如 +、-、*、/ 等，由(汇编)编译器识别，没有对应的机器码
   
2. 在内存中，指令和数据没有任何区别，都是**二进制信息**，一段二进制信息即可以被 CPU 解读成指令，也可以被解读成数据

3. 在 CPU 和其他各类设备中连接着**总线**，总线分为：
   + 地址总线：**地址总线的宽度决定了 CPU 的寻址能力**，假如地址总线的宽度是 N，那么 CPU 的寻址能力就是 2^N 个 Byte
   + 数据总线：**数据总线的宽度决定了 CPU 和外界的数据传送速度**
   + 控制总线：**控制总线的宽度决定了 CPU 对外部器件的控制能力**
   
4. 各类存储器芯片
   + 随机存储器由装在主板上的 RAM(不知道啥玩意，是寄存器？) 和插在扩展槽上的内存条组成
   + BIOS 不止主板上的那一个（系统 BIOS），显卡、网卡等设备也有对应的 BIOS，BIOS 都是 ROM
   + 显卡上的显存也是 RAM
   
5. 内存地址空间

   + 各类存储器芯片都和 CPU 的总线相连
   + CPU 在操控它们的时候，把它们都当作内存来对待，把它们总的看作**一个**由若干存储单元组成的<u>逻辑存储器</u>，这个逻辑存储器就是**内存地址空间**

   > 从 CPU 的视角来看，各类存储器芯片的内存单元是一个**连续内存空间**（而从编程的角度只能看到一个进程的虚拟内存空间），所以当我们想在某类存储器中读写数据的时候，必须知道它的第一个单元的地址和最后一个单元的地址，才能保证读写操作是在预期的存储器中进行。
   
   ![image-20230801211334134](https://raw.githubusercontent.com/chi199702/notes/main/image/image-20230801211334134.png)
   
   ## 第 2 章 寄存器
   
   1. 通用寄存器
   
      通用寄存器的高 8 位和低 8 位可以分开使用，但是不要错误的认为低位产生的进位会应存储在高位上，它们是没有任何关系的。同时在进行数据传送或运算时，指令的两个操作数的位数应当是一致的。
   
   2. 16 位结构的 CPU 的含义
   
      16 位结构（16 位机、字长为 16 位等）描述了一个 CPU 具有下面几方面的结构特性：
   
      + 运算器一次最多可以处理 16 位的数据
      + 寄存器的最大宽度为 16 位
      + 寄存器和运算器之间的通路为 16 位
   
   3. 8086CPU 计算物理地址的方法
   
      8086CPU 的地址总线宽度是 20 位，但是其是 16 位结构的 CPU，其计算物理地址的方式是：**段地址 * 16（基地址） + 偏移地址**。**段的起始地址一定是 16 的倍数，由于偏移地址是 16 位，所以一个段的最大长度是 64KB。**
      
   4. CS 和 IP 寄存器
   
      CS 是**代码段**寄存器，IP 是 指令指针寄存器，任何时刻 CPU 都运行 CS 和 IP 指向的内存中的指令。**这也说明了 CPU 只把 CS : IP  指向的内容当作指令。**
   
      在 8086 CPU 上修改 CS : IP 的值只能通过**jmp 段地址 : 偏移地址**的形式，这样段地址的值会被赋值给 CS，偏移地址的值会被赋值给 IP。
   
   ## 第 3 章 寄存器（内存访问）
   
   1. 8086 CPU 采用**小端字节序**存储。分清楚 2 个概念，N 地址单元和 N 地址<u>字</u>单元分别存放了 1 个字节和 1 个字。
   2. DS 是**数据**段寄存器，同 cs 寄存器一样，不能通过`mov ds, 1000H`这种给 ds 赋值立即数的方式来使用，只能给其赋值通用寄存器的值。其使用方式为`mov ax, [address]`，这时**内存单元**的 ds : address 中的内容会被赋值给 ax。
   3. 假设 ds = 1000H，那么`mov al, [0010]`和`mov ax, [0010]`的效果是完全不同的，前者只会将 1000 : 0010 这个内存单元的单个字节赋值给 al，后者会将 1000 : 0011 和 1000 : 0010 这两个字节形成的字赋值给 ax，反过来，`mov [0010], al`和`mov [0010], ax`也一样。
   4. 栈顶的段地址存放在 SS 中，偏移地址存放在 SP 中。SS : SP 指向栈顶元素。**栈操作都是以字为单位的**，`push ax`的执行过程分为（pop 则与此相反）：
      1. SP -= 2
      2. 将 ax 的值压入 SS : SP 中
   5. push 和 pop 实际上是一种内存传送指令，而且8086 CPU 并没有安排记录栈顶上限和栈底下限的寄存器来标志出栈空间的范围。
   6. 一个栈段的最大变化范围是**0000-FFFF**，就是 64KB，当栈满时再压栈的话 FFFF + 2 就是 0001，导致**栈底的内容被覆盖。**
   
   > 我们可以自定义数据段、代码段、栈段：
   >
   > + 对于数据段，将它的段地址放在 DS 中，用 mov、add、sub 等访问内存单元`[address]`的指令时，CPU 就将我们定义的数据段中的内容当作数据而不是代码来访问。
   > + 对于代码段，将它的段地址放在 CS 中，将段中第一条指令的偏移地址放在 IP 中，这样 CPU 就将执行我们定义的代码段中的指令。
   > + 对于栈段，将它的段地址放在 SS 中，将栈顶单元的偏移地址放在 SP 中，这样 CPU 在需要进行栈操作的时候，就将我们定义的栈段当作栈空间来用。
   
   ## 第 4 章 第一个程序
   
   1. 伪指令由编译器识别，其没有对应的机器码所以不会翻译成机器语言。
   2. `xxx segment`和`xxx ends`标志着一个段，一个汇编程序是由多个段组成的，这些段被用来存放数据、代码或被当作栈空间来使用。
   3. assume 用来将相关的段寄存器和有特定用途的段相关联起来，其使用格式为`assume 段寄存器 : 段名`。
   4. 程序返回：一个程序结束后，将 CPU 的控制权交还给使它得以运行的程序，使用这两条指令来实现`mov ax, 4c00H`和`int 21H`。
   5. 使用 debug 将程序载入内存后，debug 并不放弃对 CPU 的控制权，所以能进行单步调试，同时发现**cx 中存放的是程序的长度。**
   
   
